# -*- coding: utf-8 -*-

# 이진(이분) 탐색으로 풀이
# 풀이를 생각해 내기 어려울 수도 있지만 
# 이진 탐색 문제라는 것만 기억하고 그에 맞게 풀이를 생각하면 쉽게 풀 수 있다.

# 풀이를 간략하게 설명하자면
# 모든 랜선의 길이의 합을 N(필요한 개수)로 나누고, 
# 0 ~ '나눈 값' 범위에서 이진 탐색을 하면 된다.
# 최대 값을 구해야 하기 때문에 왼쪽 인덱스가 오른쪽 인덱스를 넘어가기 까지 while문을 실행한다.

# 당황했던 부분은 '런타임 에러 (ZeroDivisionError)' 오류가 발생했을 때인데,
# 위 오류는 쉽게 말해서 0으로 나누게 되는 경우가 있을 경우 발생한다.
# 오류가 생겼던 부분에서 설명하겠다.

import sys

# 입력값을 차례로 입력 받는다.
K, N = map(int, sys.stdin.readline().split())

Lans = [int(sys.stdin.readline()) for _ in range(K)]

# 이진 탐색을 위해 왼쪽 인덱스, 오른쪽 인덱스를 생성한다.
left = 0
# 위에서 설명했듯, 전체 길이에서 필요한 개수만큼 나누어 준다.
right = sum(Lans) // N

# 이진 탐색을 하는 함수이다.
def binary(N, Lans, left, right):
    # 이진 탐색의 중심 인덱스를 맡을 변수
    mid = 0

    # 왼쪽 인덱스가 오른쪽 인덱스보다 같거나 작을동안 실행한다.
    while left <= right:
        # 중심 인덱스를 갱신
        mid = ((left+right) // 2)

        # 밑의 'total += (i // mid) 부분에서 'ZeroDivisionError' 오류가 발생했다.
        # 예상하건데 경우 중에 왼쪽 인덱스와 오른쪽 인덱스가 0과 1이 됐을 경우에 발생하는 것 같다.
        # -> '(0+1) // 2' 는 0이 되므로
        # 그래서 그냥 0이 되는 경우는 탈출하게 했더니 해결됐다.
        if mid == 0:
            break

        # 중심 인덱스의 길이로 몇개의 랜선이 나오나 확인하는 과정이다.
        total = 0
        for i in Lans:
            total += (i // mid)

        # 만약 필요한 개수보다 많을 경우 
        # -> 랜선을 더 크게 분할해야 하므로 왼쪽 인덱스를 이동
        # 만약 필요한 개수와 같을 경우 
        # -> 최대 값을 구해야 하기 때문에 끝내지 않고 왼쪽 인덱스를 이동
        if total >= N:
            left = mid + 1
        # 만약 필요한 개수보다 적을 경우
        # -> 더 작게 분할해야 하므로 오른쪽 인덱스 이동
        else:
            right = mid - 1

    # mid가 아닌 right을 출력하는 이유는
    # while문이 끝났을 경우, 그 때의 right 값이 최대 값이기 때문
    print(right)
    
# 이진 탐색 함수 실행
binary(N, Lans, left, right)