# 문제 이해가 중요하다고 생각
# 회문 조건으로 봤을 때 
# 0이 되는 조건 : 완벽한 대칭 일 때
# 1이 되는 조건 : 하나를 뺀다면 완벽한 대칭 일 때
# 2가 되는 조건 : 나머지의 경우 -> 대칭을 위하여 빼야할 문자가 2개 이상일 때
# 위 조건을 구분하여 문자열을 확인

import sys

# 입력 받을 문자열 개수
T = int(sys.stdin.readline())

# 결과값을 저장 할 리스트
result = []

# 대칭이 아닌 두번째 요소를 찾기 전까지의 함수 -> 2개 이상 틀리면 의미가 없으므로
def test_2(S, p_l, p_r):
    # 대칭이 아닌 요소가 있다면 1로 설정 할 변수
    r = 0

    # 왼쪽 인덱스와 오른쪽 인덱스가 같거나 가로지르지 않고, r이 1보다 작을 때까지 반복
    # -> 하나만 나오면 test_1에서 2가 되므로
    while p_l < p_r and r < 1:
        # 왼쪽, 오른쪽 요소가 같다면
        if S[p_l] == S[p_r]:
            # 다음 인덱스로 이동
            p_l += 1
            p_r -= 1
        # 다르다면
        else:
            # r을 1로 설정 -> 조건에 의해 반복문 종료
            r += 1
    # 결과 반환
    return r

# 대칭이 아닌 첫번째 요소를 찾기 전까지의 함수
def test_1(S, p_l, p_r):
    # 문자열의 결과 값인 0, 1, 2를 저장 할 변수
    r = 0

    # 왼쪽, 오른쪽 인덱스가 같거나 가로지르지 않고, r이 2보다 작을 때까지 반복
    # -> r이 2 이상이면 전부 2인 경우이므로
    while p_l < p_r and r < 2:
        # 만약 왼쪽 인덱스의 요소가 오른쪽 인덱스의 요소가 같다면
        # 왼쪽은 +1, 오른쪽은 -1
        if S[p_l] == S[p_r]:
            p_l += 1
            p_r -= 1
        # 다르다면
        else:
            # 하나를 발견 했으므로 1인 경우로 설정
            r += 1
            # 왼쪽 요소와 오른쪽의 요소 중 대칭이 아닌 요소가 뭔지 알 수 없기 때문에
            # 두 경우다 확인 -> 하나만 더 찾으면 더 이상 의미가 없으므로 나머지 요소들은 test_2에서 전부 확인
            t_1 = test_2(S, p_l, p_r-1)
            t_2 = test_2(S, p_l+1, p_r)

            # test_2에서 대칭이 아닌 요소가 하나라도 나왔다면
            if t_1 != 0 and t_2 != 0:
                # 문자열의 결과를 2로 설정
                r += 1
            # 나오지 않았다면 결과 1인채로 반복문 탈출
            else:
                break
    # 결과 반환
    return r

# 문자열을 입력 받아 회문 조건 확인    
for _ in range(T):
    S = list(map(str, sys.stdin.readline().rstrip()))

    # 문자열의 왼쪽 끝과 오른쪽 끝의 인덱스
    # p_l은 오른쪽으로, p_r은 왼쪽으로 이동하면서 확인
    # 두개의 인덱스가 같아지거나 가로지르면 종료
    p_l = 0
    p_r = len(S) - 1

    # test_1에서 확인한 문자열의 종류를 결과 리스트에 추가
    # 문자열과 왼쪽, 오른쪽 끝 인덱스를 넘겨줌
    result.append(test_1(S, p_l, p_r))

# 결과 출력
for i in result:
    print(i)

    